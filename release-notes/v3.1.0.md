# Nodots Backgammon Core v3.1.0 - Release Notes

**Release Date**: December 30, 2024  
**Version**: 3.1.0  
**Type**: Minor Release

## üéØ **Overview**

This release introduces the **'preparing-move' state** as a proper intermediary state in the backgammon game flow, replacing the previous direct transitions from 'rolled' to 'moving' or 'doubling'. This creates a cleaner, more explicit state machine that better represents the decision-making process in backgammon.

## ‚ö†Ô∏è **BREAKING CHANGES**

This is a **breaking change** that removes backward compatibility in favor of a cleaner architecture:

### State Transition Changes

**Previous Flow (v3.0.x):**

```
rolled ‚Üí moving (direct)
rolled ‚Üí doubling (direct)
```

**New Flow (v3.1.0):**

```
rolled ‚Üí preparing-move ‚Üí moving
rolled ‚Üí preparing-move ‚Üí doubling
```

### API Changes

1. **`Game.toMoving()`** - Now only accepts `preparing-move` or `doubled` states

   - ‚ùå `Game.toMoving(rolledGame)` - **No longer supported**
   - ‚úÖ `Game.toMoving(Game.prepareMove(rolledGame))` - **Required flow**

2. **`Game.toDoubling()`** - Now only accepts `preparing-move` states

   - ‚ùå `Game.toDoubling(rolledGame)` - **No longer supported**
   - ‚úÖ `Game.toDoubling(Game.prepareMove(rolledGame))` - **Required flow**

3. **`Game.startMoving()`** - **Removed** (deprecated method)

   - ‚ùå `Game.startMoving()` - **Method removed**
   - ‚úÖ `Game.toMoving()` - **Use this instead**

4. **`Game.canOfferDouble()`** - **Stricter validation**
   - ‚ùå Can no longer double from `rolled` state
   - ‚úÖ Must be in `preparing-move` state to double

## ‚ú® **New Features**

### 1. Preparing-Move State

- **`Game.prepareMove(game: BackgammonGameRolled)`**
  - Transitions from 'rolled' to 'preparing-move' state
  - Represents the moment when a player is about to make a decision
  - Required before any move or double action

### 2. Enhanced State Validation

- Stricter state machine enforcement
- Clear error messages for invalid state transitions
- Explicit validation at each transition point

### 3. Improved Doubling Logic

- Players can **only** offer doubles from 'preparing-move' state
- More accurate representation of when doubling decisions occur
- Cleaner separation between rolling and decision-making

## üîß **Technical Improvements**

### State Machine Flow

The new state machine provides clearer semantics:

```typescript
// Correct usage in v3.1.0
const rolledGame = Game.roll(gameRolling)
const preparingGame = Game.prepareMove(rolledGame)

// Option 1: Move
const movingGame = Game.toMoving(preparingGame)

// Option 2: Double
const doublingGame = Game.toDoubling(preparingGame)
```

### Error Handling

Enhanced error messages for invalid transitions:

- `"Cannot start moving from rolled state. Must be in 'preparing-move' or 'doubled' state."`
- `"Cannot start doubling from rolled state. Must be in 'preparing-move' state."`
- `"Cannot prepare move from moving state"`

### Type Safety

- Updated TypeScript interfaces for stricter type checking
- Better IntelliSense support for valid state transitions
- Compile-time prevention of invalid state flows

## üì¶ **Updated Components**

### Core Game Engine

- `Game.prepareMove()` - New method for state transition
- `Game.toMoving()` - Updated parameter types (breaking change)
- `Game.toDoubling()` - Updated parameter types (breaking change)
- `Game.canOfferDouble()` - Stricter validation rules
- `Game.startMove()` - Updated helper method signatures

### Move Processing

- Robot execution flow updated for new state transitions
- Simulation scripts updated to use proper flow
- All internal state transitions follow new pattern

### Test Suite

- All tests updated to use new state flow
- Added comprehensive validation for state transitions
- 24/24 test suites passing with new implementation

## üìà **Performance & Quality**

### Test Results

- ‚úÖ **24/24 test suites passing**
- ‚úÖ **203/203 tests passing**
- ‚úÖ **All robot simulations working correctly**
- ‚úÖ **Zero regression in functionality**

### Code Quality

- Cleaner state machine logic
- Reduced complexity in state transition methods
- More predictable game flow behavior
- Better separation of concerns

## üöÄ **Migration Guide**

### For API Consumers

**Before (v3.0.x):**

```typescript
const rolledGame = Game.roll(gameRolling)
const movingGame = Game.toMoving(rolledGame) // Direct transition
```

**After (v3.1.0):**

```typescript
const rolledGame = Game.roll(gameRolling)
const preparingGame = Game.prepareMove(rolledGame) // Required step
const movingGame = Game.toMoving(preparingGame) // Explicit transition
```

### For Doubling Logic

**Before (v3.0.x):**

```typescript
if (Game.canOfferDouble(rolledGame, player)) {
  const doublingGame = Game.toDoubling(rolledGame)
}
```

**After (v3.1.0):**

```typescript
const preparingGame = Game.prepareMove(rolledGame)
if (Game.canOfferDouble(preparingGame, player)) {
  const doublingGame = Game.toDoubling(preparingGame)
}
```

### Automated Migration

Replace these patterns in your codebase:

1. `Game.toMoving(rolledGame)` ‚Üí `Game.toMoving(Game.prepareMove(rolledGame))`
2. `Game.toDoubling(rolledGame)` ‚Üí `Game.toDoubling(Game.prepareMove(rolledGame))`
3. `Game.startMoving(...)` ‚Üí `Game.toMoving(...)`

## üîç **Why This Change?**

### Better Game Representation

- The 'preparing-move' state accurately models the moment when a player has rolled dice and must decide their action
- Clearer separation between "dice rolled" and "decision made"
- More intuitive for game UI implementations

### Improved State Management

- Eliminates ambiguity in state transitions
- Provides explicit hook for UI decision points
- Better foundation for future enhancements (e.g., time limits, hints)

### Code Quality

- Removes implicit state transitions
- Makes game flow more predictable and debuggable
- Easier to reason about game state at any point

## üõ† **Development Impact**

### For Game UI Development

The new state provides a perfect hook for UI decision points:

```typescript
if (game.stateKind === 'preparing-move') {
  // Show move/double decision UI
  // Player can choose to move or double
  // Clear visual indicator of decision point
}
```

### For AI Development

The explicit state makes AI decision logic clearer:

```typescript
// AI can analyze position during preparing-move state
// Clear separation between rolling and decision-making
// Better hooks for move/double evaluation
```

## üìä **Compatibility**

### Supported Node.js Versions

- Node.js 16.x ‚úÖ
- Node.js 18.x ‚úÖ
- Node.js 20.x ‚úÖ
- Node.js 22.x ‚úÖ

### Database Compatibility

- No database schema changes required
- Existing games continue to work normally
- State transitions handled automatically

### Package Dependencies

- `@nodots-llc/backgammon-types`: Compatible with all versions
- No changes to external dependencies required

## üîÆ **Future Enhancements**

This change lays the groundwork for:

- **Timed decisions**: Adding time limits during preparing-move state
- **Move hints**: Providing suggestions during decision phase
- **Advanced UI**: Richer interaction patterns for move/double choices
- **Analytics**: Better tracking of decision-making patterns
- **Tournament features**: Proper handling of competitive game rules

## üìû **Support**

### Documentation

- Updated API documentation available
- Migration examples in this release note
- All existing documentation updated for new flow

### Issues & Questions

- File issues on the project repository
- Check existing tests for usage examples
- Refer to migration guide above for common patterns

---

## üéâ **Summary**

Version 3.1.0 delivers a **cleaner, more explicit state machine** that better represents backgammon's decision-making flow. While this introduces breaking changes, the migration is straightforward and results in more maintainable, predictable code.

**Key benefits:**

- ‚úÖ Cleaner state machine architecture
- ‚úÖ Better separation of concerns
- ‚úÖ More explicit game flow
- ‚úÖ Foundation for future enhancements
- ‚úÖ Improved developer experience

**Upgrade today** to take advantage of the improved architecture and prepare for upcoming features that will build on this solid foundation.

---

**Next Release**: v3.2.0 (planned features: enhanced robot AI, move validation improvements)
